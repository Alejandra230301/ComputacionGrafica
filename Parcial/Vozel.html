<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Parcial</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				background-color: #f0f0f0;
				color: #444;
			}
			a {
				color: #08f;
			}
		</style>
	</head>
	<body>

		<div id="info">
			Alejandra Pedraza Cardenas - 6000370 <br>
			<strong>click</strong>: a√±adir voxel, <strong>shift + click</strong>: remove voxel,
			<strong>Tecla A</strong>: primera figura, <strong>Tecla S</strong>: segunda figura,<strong>Tecla D</strong>: tercera figura,<strong>Tecla F</strong>: cuarta figura
		</div>
        <script src="js/three.js"></script>
	    <script src="js/controls/OrbitControls.js"></script>
		<script src="js/csg.js"></script>
	    <script src="js/THREE.CSG.js"></script>
        <script src="js/three.module.js"></script>
        <div id="menu">
        </div>
        <script>


			var camera, scene, renderer;
			var plane, voxel;
			var mouse, raycaster, isShiftDown, Figura1, Figura2, Figura3, Figura4, rotacion;
			var controls; 

			var rollOverMesh, rollOverMaterial, rollOverMesh1,rollOverMesh2,rollOverMesh3;
			var ficha1, ficha1Material;
            var ficha2, ficha2Material;
            var ficha3, ficha3Material;
            var ficha4, ficha4Material;

			var objects = [];

			init();
			render();

			function init() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 500, 800, 1300 );
				camera.lookAt( 0, 0, 0 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xf0f0f0 );
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
			    controls = new THREE.OrbitControls( camera, renderer.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'keydown', onDocumentKeyDown, false );
				document.addEventListener( 'keyup', onDocumentKeyUp, false );

				// roll-over helpers
				// cubes
                
                ficha1 = generarFicha1();
                ficha1Material = new THREE.MeshStandardMaterial( { color: 0x0098F5,  metalness: 0.5, roughness: 0.1});

                ficha2 = generarFicha2();
                ficha2Material = new THREE.MeshStandardMaterial( { color: 0x6BDD00,  metalness: 0.5, roughness: 0.1});

                ficha3 = generarFicha3();
                ficha3Material = new THREE.MeshStandardMaterial( { color: 0xFFCB41,  metalness: 0.5, roughness: 0.1});

                ficha4 = generarFicha4();
                ficha4Material = new THREE.MeshStandardMaterial( { color: 0xE1DD00,  metalness: 0.5, roughness: 0.1});

				rollOverMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.5, transparent: true } );


				rollOverMesh = new THREE.Mesh( ficha1.geometry, rollOverMaterial );
				rollOverMesh1 = new THREE.Mesh( ficha2.geometry, rollOverMaterial );
				rollOverMesh2 = new THREE.Mesh( ficha3.geometry, rollOverMaterial );
				rollOverMesh3 = new THREE.Mesh( ficha4.geometry, rollOverMaterial );

													
				            

				// grid

				var gridHelper = new THREE.GridHelper( 1000, 20 );
				scene.add( gridHelper );

				//

				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();

				var geometry = new THREE.PlaneBufferGeometry( 1000, 1000 );
				geometry.rotateX( - Math.PI / 2 );

				plane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { visible: false } ) );
				scene.add( plane );

				objects.push( plane );

				// lights

                var ambientLight = new THREE.AmbientLight( 0x606060 );
			scene.add( ambientLight );

			var directionalLight = new THREE.DirectionalLight( 0xffffff );
			directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
			scene.add( directionalLight );


				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

            function generarFicha1(){
                var fichaGeo = new THREE.BoxBufferGeometry( 50, 50, 50 );
                var fichaMaterial = new THREE.MeshBasicMaterial( { color: 0x0070F5});
                var ficha = new THREE.Mesh( fichaGeo, fichaMaterial );
                var geometry = new THREE.CylinderGeometry( 7, 7, 8, 32 );
                var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
                var cylinder = new THREE.Mesh( geometry, material );
                cylinder.translateY(28);
                cylinder.translateZ(15);
                cylinder.translateX(-13);
                var cylinder1 = cylinder.clone();
                cylinder1.translateX(26);
                var cylinder2 = cylinder.clone();
                cylinder2.translateZ(-30);
                var cylinder3 = cylinder1.clone();
                cylinder3.translateZ(-30);
                var ficha1 = THREE.CSG.fromMesh(ficha);
                var c1 = THREE.CSG.fromMesh(cylinder);
                var c2 = THREE.CSG.fromMesh(cylinder1);
                var c3 = THREE.CSG.fromMesh(cylinder2);
                var c4 = THREE.CSG.fromMesh(cylinder3);
                var un = ficha1.union(c1.union(c2.union(c3.union(c4))));
                var ficha1Def = THREE.CSG.toMesh(un);
             
               return ficha1Def;
            }

            function generarFicha2(){
                var fichaGeo1 = new THREE.BoxBufferGeometry( 100, 50, 50 );
			var fichaMaterial1 = new THREE.MeshBasicMaterial( { color: 0x0070F5});
			var ficha1 = new THREE.Mesh( fichaGeo1, fichaMaterial1 );
			var geometry1 = new THREE.CylinderGeometry( 7, 7, 8, 32 );
            var material1 = new THREE.MeshBasicMaterial( {color: 0xffff00} );
            var cylinders = new THREE.Mesh( geometry1, material1 );
			cylinders.translateY(28);
			cylinders.translateZ(15);
			cylinders.translateX(-13);
			var cylinders1 = cylinders.clone();
			cylinders1.translateX(26);
			var cylinders2 = cylinders.clone();
			cylinders2.translateZ(-30);
			var cylinders3 = cylinders1.clone();
			cylinders3.translateZ(-30);
			var cylinders4 = cylinders.clone();
			cylinders4.translateX(-26);
			var cylinders5 = cylinders1.clone();
			cylinders5.translateX(26);
			var cylinders6 = cylinders3.clone();
			cylinders6.translateX(26);
			var cylinders7 = cylinders2.clone();
			cylinders7.translateX(-26);
			var fichaa1 = THREE.CSG.fromMesh(ficha1);
			var cs1 = THREE.CSG.fromMesh(cylinders);
			var cs2 = THREE.CSG.fromMesh(cylinders1);
			var cs3 = THREE.CSG.fromMesh(cylinders2);
			var cs4 = THREE.CSG.fromMesh(cylinders3);
			var cs5 = THREE.CSG.fromMesh(cylinders4);
			var cs6 = THREE.CSG.fromMesh(cylinders5);
			var cs7 = THREE.CSG.fromMesh(cylinders6);
			var cs8 = THREE.CSG.fromMesh(cylinders7); 
			var uni = fichaa1.union(cs1.union(cs2.union(cs3.union(cs4.union(cs5.union(cs6.union(cs7.union(cs8))))))));
			var ficha1Defi = THREE.CSG.toMesh(uni);
             
               return ficha1Defi;
            }
            function generarFicha3(){
                var fichaGeo = new THREE.BoxBufferGeometry( 50, 50, 50 );
			var fichaMaterial = new THREE.MeshBasicMaterial( { color: 0x0070F5, opacity: 0.5});
			var ficha = new THREE.Mesh( fichaGeo, fichaMaterial );
			var geometry = new THREE.CylinderGeometry( 50, 50, 50, 32 );
            var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
            var cylinder = new THREE.Mesh( geometry, material );
			cylinder.position.x = 25;
			cylinder.position.y = -23;
			cylinder.rotation.x = (Math.PI)/2;
			var ficha1 = THREE.CSG.fromMesh(ficha);
            var c1 = THREE.CSG.fromMesh(cylinder);
            var int = c1.intersect(ficha1);
			var resultado = THREE.CSG.toMesh(int);
			var geometry1 = new THREE.CylinderGeometry( 7, 7, 30, 32 );
            var material1 = new THREE.MeshBasicMaterial( {color: 0xffff00} );
            var cylinder1 = new THREE.Mesh( geometry1, material1 );
			cylinder1.position.y = 17;
			cylinder1.position.x = 15;
			cylinder1.position.z = 15;
			cylinder2 = cylinder1.clone();
			cylinder2.position.z = -15;
			var cp = THREE.CSG.fromMesh(cylinder1);
            var cp2 = THREE.CSG.fromMesh(cylinder2);
			var fichat = THREE.CSG.fromMesh(resultado);
			var un = fichat.union(cp.union(cp2));
			var final = THREE.CSG.toMesh(un);
			final.scale.y = 50;
             
               return final;
            }

            function generarFicha4(){
                var fichaGeo = new THREE.BoxBufferGeometry( 50, 50, 50 );
                var fichaMaterial = new THREE.MeshBasicMaterial( { color: 0x0070F5});
                var ficha = new THREE.Mesh( fichaGeo, fichaMaterial );
                var geometry = new THREE.CylinderGeometry( 7, 7, 8, 32 );
                var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
                var cylinder = new THREE.Mesh( geometry, material );
                cylinder.translateY(28);
                cylinder.translateZ(15);
                cylinder.translateX(-13);
                var cylinder1 = cylinder.clone();
                cylinder1.translateX(26);
                var cylinder2 = cylinder.clone();
                cylinder2.translateZ(-30);
                var cylinder3 = cylinder1.clone();
                cylinder3.translateZ(-30);
                var ficha1 = THREE.CSG.fromMesh(ficha);
                var c1 = THREE.CSG.fromMesh(cylinder);
                var c2 = THREE.CSG.fromMesh(cylinder1);
                var c3 = THREE.CSG.fromMesh(cylinder2);
                var c4 = THREE.CSG.fromMesh(cylinder3);
                var un = ficha1.union(c1.union(c2.union(c3.union(c4))));
                var ficha1Def = THREE.CSG.toMesh(un);
				var fichaC = new THREE.BoxBufferGeometry( 50, 50, 50 );
                var fichaC = new THREE.Mesh( fichaGeo, fichaMaterial );
				fichaC.rotation.z = 10;
				fichaC.position.x = -33;
				fichaC.position.y = -18;
				var a = THREE.CSG.fromMesh(ficha1Def);
                var b = THREE.CSG.fromMesh(fichaC);
				var sub = a.subtract(b);
				var ficha1es = THREE.CSG.toMesh(sub);

               return ficha1es;
            }


			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				event.preventDefault();

				mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( objects );

				if ( intersects.length > 0 ) {

					var intersect = intersects[ 0 ];

                     				
				if(Figura1){

                  

					scene.remove( rollOverMesh3 );
					scene.remove( rollOverMesh1 );
					scene.remove( rollOverMesh2 );
                    rollOverMesh.position.copy( intersect.point ).add( intersect.face.normal );
					rollOverMesh.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );	
                    scene.add( rollOverMesh );


   
					}
					//scene.remmove( rollOverMesh );


					if(Figura2){


					scene.remove( rollOverMesh );
					scene.remove( rollOverMesh2 );
					scene.remove( rollOverMesh3 );
						rollOverMesh1.position.copy( intersect.point ).add( intersect.face.normal );
										rollOverMesh1.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25);
					scene.add( rollOverMesh1 );


					}
					//scene.remove( rollOverMesh1 );

					if(Figura3){


						scene.remove( rollOverMesh1 );
						scene.remove( rollOverMesh3 );
						scene.remove( rollOverMesh );
						rollOverMesh2.position.copy( intersect.point ).add( intersect.face.normal );
										rollOverMesh2.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );
					scene.add( rollOverMesh2 );

					}
					//scene.remove( rollOverMesh2 );
					if(Figura4){


						
						scene.remove( rollOverMesh2 );
						scene.remove( rollOverMesh1 );
						scene.remove( rollOverMesh );
					rollOverMesh3.position.copy( intersect.point ).add( intersect.face.normal );
										rollOverMesh3.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );
										scene.add( rollOverMesh3 );




									}
									//scene.remove( rollOverMesh3 );
				}
				
				render();

			}

			function onDocumentMouseDown( event ) {


				event.preventDefault();

				mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( objects );

				if ( intersects.length > -1 ) {

					var intersect = intersects[ 0 ];

					// delete cube

					if ( isShiftDown ) {

						if ( intersect.object !== plane ) {

							scene.remove( intersect.object );

							objects.splice( objects.indexOf( intersect.object ), 1 );

						}

						// create cube

					} else {

						if(Figura1){

						voxel = new THREE.Mesh( ficha1.geometry, ficha1Material );
                        //console.log(fichaGeo);
						voxel.position.copy( intersect.point ).add( intersect.face.normal );
						voxel.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );
						scene.add( voxel );

						objects.push( voxel );
					}
						if(Figura2){

						voxel = new THREE.Mesh( ficha2.geometry, ficha2Material );
                        //console.log(fichaGeo);
						voxel.position.copy( intersect.point ).add( intersect.face.normal );
						voxel.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25);
						scene.add( voxel );

						objects.push( voxel );

					}

					if(Figura3){

						voxel = new THREE.Mesh( ficha3.geometry, ficha3Material );
						//console.log(fichaGeo);
						voxel.position.copy( intersect.point ).add( intersect.face.normal );
						voxel.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );
						scene.add( voxel );

						objects.push( voxel );
				}
				if(Figura4){

						voxel = new THREE.Mesh( ficha4.geometry, ficha4Material );
						//console.log(fichaGeo);
						voxel.position.copy( intersect.point ).add( intersect.face.normal );
						voxel.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );
						scene.add( voxel );

						objects.push( voxel );
					}
					}

					render();

				}

			}

			function onDocumentKeyDown( event ) {

				switch ( event.keyCode ) {
                    
					case 16: isShiftDown = true; break;
					case 65: 
					Figura1 = true;
					Figura2 = false;
					Figura3 = false;
					Figura4 = false;
					rotacion = false;
					break;
					case 83:
					Figura1 = false;
					Figura2 = true;
					Figura3 = false;
					Figura4 = false;
					rotacion = false;
					break;
					case 68: 
					Figura1 = false;
					Figura2 = false;
					Figura3 = true;
					Figura4 = false;
					rotacion = false;
					break;
					case 70:
					Figura1 = false;
					Figura2 = false;
					Figura3 = false;
					Figura4 = true;
					rotacion = false;
					break;
					case 87:
					rotacion = true;
					break;


				}

			}

			function onDocumentKeyUp( event ) {

				switch ( event.keyCode ) {

					case 16: isShiftDown = false; break;
					case 65: 
					Figura1 = true;
					Figura2 = false;
					Figura3 = false;
					Figura4 = false;
					rotacion = false;
					break;
					case 83:
					Figura1 = false;
					Figura2 = true;
					Figura3 = false;
					Figura4 = false;
					rotacion = false;
					break;
					case 68: 
					Figura1 = false;
					Figura2 = false;
					Figura3 = true;
					Figura4 = false;
					rotacion = false;
					break;
					case 70:
					Figura1 = false;
					Figura2 = false;
					Figura3 = false;
					Figura4 = true;
					rotacion = false;
					break;
					case 87:
					rotacion = false;
					break;

				}

			}

			function animate(){
			requestAnimationFrame( animate );
			controls.update();
			render();
		}

			function render() {

				var varRot = (Math.PI/2);

				if(rotacion){
					//rollOverMesh.rotation.y = Math.PI/2;
                      voxel.rotation.y = varRot;
				}

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>